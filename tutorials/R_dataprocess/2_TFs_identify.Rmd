---
title: "2. Inference of core TFs"
author: "Yukai You"
date: '2024-10-09'
output: html_document
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Step 1: Load the TF-target gene database from NetAct and gene clustering results 

For the TF-target gene database from NetAct, retain only the transcription factors (TFs) that have more than 5 target genes.
In this example, we didn't consider cluster #7 due to high noises in gene expression. 

```{r}

library(NetAct)
library(stringr)
library(ggplot2)
back_gens=readRDS("genenames.rds")
test=back_gens
test.split2<-cbind(test,1)
name<-str_split_fixed(test.split2[,1],"_",2)
back_gens<-name[,2]

cluster.results.rr=readRDS("2geneclusters_dis_02_025.rds")
data(hDB)
lens = sapply(hDB, length)
ids = which(lens >= 5)
hDB = hDB[ids]
#hDB=c(hDB, addhDB) you can add your databased as this.

cluster.results.rr[[7]] <- NULL
b2=c(NULL)
for( i in 1:length(cluster.results.rr)){
  test=cluster.results.rr[[i]]
  test.split2<-cbind(test,1)
  name<-str_split_fixed(test.split2[,1],"-",2)
  test.name<-name[,2]
  cluster.results.rr[[i]] = test.name
  b2=c(b2,test.name)
}
```

#### Step 2: Inference of core TFs using Fisher's Exact Test 

For each of the 6 gene clusters, we performed Fisher's exact tests to identify enriched TFs with q-value smaller than 0.1. We excluded TFs that are absent from the six gene clusters. 
(ML: verify this)

```{r}
TF=c(intersect(b2,names(hDB)))
TF.hDB = hDB[TF]
final.results = c(NULL)
for (k in 1:length(TF)) {
  test.name = TF.hDB[[k]]
  listA = cluster.results.rr
  
  # Dynamically create names for listA based on its length
  names(listA) = paste0("g", 1:length(listA))
  
  nameB = test.name
  background = back_gens
  number = vector(mode = "list", length = length(listA))
  
  for (i in 1:length(listA)) {
    a = length(background[background %in% listA[[i]] & background %in% nameB])
    b = length(background[background %in% listA[[i]] & !(background %in% nameB)])
    c = length(background[background %in% nameB & !(background %in% listA[[i]])])
    d = length(background[!(background %in% c(listA[[i]], nameB))])
    fish.mat <- matrix(c(a, c, b, d), nrow = 2, ncol = 2)
    fish <- fisher.test(fish.mat, alternative = "greater")
    number[[i]] = fish$p.value
  }
  
  number2 = as.matrix(number)
  k1 = cbind(names(TF.hDB)[[k]], names(listA), number2)
  final.results = rbind(final.results, k1)
}

q_scale_groups=list()
for (i in 1:length(cluster.results.rr)){
  name_group = paste0("g", i)
  gn=final.results[final.results[,2]==name_group,]
  q_value=p.adjust(as.numeric(gn[,3]), method = "BH")
  q_scale_groups[[i]]=cbind(gn,q_value)
}


final.results= do.call(rbind,q_scale_groups)

tfs=final.results[final.results[,4]<=0.10,]
tfs=unique(tfs[order(unlist(tfs[,4])),])
tfs=as.character(unique(tfs[tfs[,4]<=0.10,1]))
```

Plotting the core TFs

```{r}

usedf=as.data.frame(final.results[final.results[,1]%in%tfs,])
usedf=usedf[which(usedf[,4]<1),]
s_object=as.numeric(usedf[,4])
logs_object=log10(s_object)

usedf=cbind(usedf,-logs_object)

colnames(usedf)=c('gene','group','p_value','q_value','size')
usedf[,1]=as.character(unlist(usedf[,1]))
usedf[,2]=as.character(unlist(usedf[,2]))

TF_plot <- ggplot(data = usedf, aes(x = group, y = gene, size = size, color = size)) +
  geom_point() +
  xlab("X-axis") +
  ylab("Y-axis") +
  ggtitle("TF") +
  scale_color_gradient(low = "blue", high = "red", name = "q-value",
                       labels = expression(10^0, 10^-1, 10^-2, 10^-3, 10^-4)) +
  scale_size_continuous(name = "q-value",
                        labels = expression(10^0, 10^-1, 10^-2, 10^-3, 10^-4)) +
  theme(
    axis.line = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    legend.title = element_text(size = 20),
    legend.text = element_text(size = 18),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    plot.title = element_text(size = 24)) +
  guides(
    size = guide_legend(reverse = TRUE))

TF_plot
```


#### Step 3: Analyzing and filtering TFs

For each TF, check if its target genes overlap significantly with the target genes of another TF.
If the target genes from two TFs significantly overlap, we selected the TF with the higher standard deviation of expression and excluded the other.

```{r}
load("fitnb.RData")
test=rownames(fit.nb5000)
test.split2<-cbind(test,1)
name<-str_split_fixed(test.split2[,1],"-",2)
rownames(fit.nb5000)<-name[,2]

tf_results <- tfs

TF.hDB2=TF.hDB[tf_results]
final.results=c(NULL)
for (k in 1:length(tf_results)){
  test.name=TF.hDB2[tf_results[k]]
  
  listA=TF.hDB2[tf_results[-k]]
  nameB=test.name[[1]]
  background=back_gens
  number= vector(mode="list",length=length(listA))
  for (i in 1:length(listA)){
    a=length(background[background%in%listA[[i]]&background%in%nameB])
    b=length(background[background%in%listA[[i]]&!(background%in%nameB)])
    c=length(background[background%in%nameB&!(background%in%listA[[i]])])
    d=length(background[!(background%in%c(listA[[i]],nameB))])
    fish.mat <- matrix(c(a,c,b,d), nrow = 2, ncol=2)
    fish <- fisher.test(fish.mat, alternative = "greater")
    number[[i]]=fish$p.value
  }
  number2=as.matrix(number)
  k1=cbind(tf_results[k],names(listA),number2)
  #k1=k1[order(as.numeric(k1[,4])),
  final.results=rbind(final.results,k1)
}


q_scale_groups=list()
for (i in 1:length(tf_results)){
  name_group=tf_results[i]
  gn=final.results[final.results[,2]==name_group,]
  q_value=p.adjust(gn[,3], method = "BH")
  q_scale_groups[[i]]=cbind(gn,q_value)
}

final.results = do.call(rbind, q_scale_groups)

final.results[final.results[,4]<=10^-20,]

# Filter final.results based on the q_value condition
filtered_results <- final.results[final.results[,4] <= 10^-20, ]
gene_pairs=filtered_results[,1:2]

# Initialize a vector to store the gene with the lower sd

lower_sd_gene <- vector("character", nrow(gene_pairs))
higher_sd_gene <- vector("character", nrow(gene_pairs))
# Loop through each pair of genes
for (i in 1:nrow(gene_pairs)) {
  gene1 <- gene_pairs[i, 1][[1]]
  gene2 <- gene_pairs[i, 2][[1]]
  
  # Calculate the standard deviation for both genes
  sd_gene1 <- sd(fit.nb5000[gene1, ])
  sd_gene2 <- sd(fit.nb5000[gene2, ])
  
  # Determine which gene has the higher and lower sd
  if (sd_gene1 > sd_gene2) {
    higher_sd_gene[i] <- gene1
    lower_sd_gene[i] <- gene2
  } else {
    higher_sd_gene[i] <- gene2
    lower_sd_gene[i] <- gene1
  }
}



filtered_results_with_sd <- cbind(filtered_results, lower_sd_gene)

genes_to_remove=unlist(unique(filtered_results_with_sd[,5]))

tf_results2 <- tf_results[!tf_results %in% genes_to_remove]

print(tf_results2)
saveRDS(tf_results2,"tfs.rds")

tf_fit=fit.nb5000[tf_results2,]

write.csv(tf_fit, file = "tf_fit.csv", row.names = TRUE) #save data for fitting

```
