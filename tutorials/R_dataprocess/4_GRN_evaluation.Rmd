---
title: "RACIPE simulations and top GRN selection"
author: "Yukai You"
date: '2024-10-11'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Step 1: Inputting GRNs into RACIPE

Once the optimal GRNs are obtained, one can use RACIPE to simulate the gene expression dynamics of each GRN. First, input all GRNs into the list `Networklist_noadd`. This step prepares the networks for further analysis and comparison with the scRNA-seq data.

```{r,echo=FALSE, results="hide", message=FALSE, warning=FALSE}
source("Function.R")
```

```{r,eval=FALSE}
Networklist_noadd <- list()
# Define the common file path
file_path <- "~/Desktop/Singlecell6.25/Finally fitting /network/"
# Loop through the file indices and read the CSV files
for (i in 31:45) {
  file_name <- paste0(file_path, "network_noadd_", i, ".csv")
  Networklist_noadd[[46 - i]] <- read_csv(file_name)
}
NetDes_noadd_results=list()
for (i2 in 1:15){
  network=Networklist_noadd[[i2]]
  for( i in 1:nrow(network)){
    if (network[i,3]>1){network[i,3]=1}
    else if (network[i,3]<1){network[i,3]=2}
    else{network[i,3]=0}
  }
  network=as.data.frame(network[,1:3])
  colnames(network)=c("Source","Target","Type")
  plot_network(network)
  rSet <- sRACIPE::sracipeSimulate(circuit = network, numModels = 10000,
                                   plots = FALSE, integrateStepSize = 0.1, 
                                   simulationTime = 30)
  
  NetDes_noadd_results[[i2]]=rSet
}


saveRDS(NetDes_noadd_results,file="Racipe_simulation.rds")
```

**Step 2: Mapping GRN Dynamics to scRNA-seq gene expression time trajectories**

Once the GRNs are simulated, one can compare the network gene expression dynamics to the smoothed gene expression trajectories from the scRNA-seq data. The quality of the mapping will be evaluated by the following metrics:

-   `percentage_NetDesnoadd`: The mapping percentage across all data dimensions.

-   `percentage_NetDesnoadd_3D`: The mapping percentage for the first three principal components (PCs).

-   `NetDesnoadd_entropy`: GRN entropy, representing the evenness of number of RACIPE models mapped to each reference cell state.

[ML: entropy not defined in Methods; no reference cell states are mentioned.]

```{r}
library(ggpointdensity)
library(MASS)
NetDes_noadd_results=readRDS("Racipe_simulation.rds")

tf_expression <- read_csv("~/Desktop/8.17/NETWORK BENCHMARK/GENIE3/tflogexpression.csv")

tf_expression=as.matrix(tf_expression)
rownames(tf_expression)=tf_expression[,1]
tf_expression=tf_expression[,-1]

numeric_vector <- 2^seq(from = -10, to = 5, by = 1)
dis_scale_NetDesnoadd=numeric(15)
percentage_NetDesnoadd=matrix(NA,ncol = 15,nrow=7)
percentage_NetDesnoadd_3D=matrix(NA,ncol = 15,nrow=7)
umap_vector_NetDesnoadd=matrix(NA,nrow=6,ncol=15)
umap_vector_random_NetDesnoadd=matrix(NA,nrow=6,ncol=15)
results_NetDesnoadd=matrix(NA,ncol = 15,nrow=7)

for (i in 1:15) {
  rSet = NetDes_noadd_results[[i]]
  
  dat1 = rSet@assays@data@listData[["deterministic"]]
  
  tf_expression2 = tf_expression[rownames(dat1), ]
  
  for (i2 in 1:nrow(dat1)) {
    tf_expression2[i2, ] = scale(as.numeric(tf_expression2[i2, ]))
  }
  
  tf_expression3 <- matrix(as.numeric(tf_expression2),    # Convert to numeric matrix
                           ncol = ncol(tf_expression2))
  rownames(tf_expression3) = rownames(tf_expression2)
  colnames(tf_expression3) = colnames(tf_expression2)
  
  opt_results = ob_bestscalevalue(RACIPE_data = dat1, real_data = tf_expression3, numeric_vector = numeric_vector)
  
  for (ib in 1:nrow(dat1)) {
    dat1[ib, ] = log2(dat1[ib, ])
  }
  
  stats_scale_2 = tf_expression3[, c(1, 40, 80, 120, 160, 201)]  ## choose gene experssion snapshots you want to use to be the baseline,
  dat_0_1 = t(scale(t(dat1)))
  
  pca_sim = prcomp(t(dat_0_1))
  pca_percentage = pca_sim$sdev^2 / sum(pca_sim$sdev^2)
  pca_percentage = pca_percentage * 100
  
  pca_df = data.frame(PC1 = pca_sim$x[, 1], PC2 = pca_sim$x[, 2], PC3 = pca_sim$x[, 3])
  
  if (i == 13) {
    p <- ggplot(pca_df, aes(x = PC1, y = PC2)) +
      geom_pointdensity(size = 3, shape = 17) +
      scale_color_viridis_c(guide = guide_colorbar(title = "# of neighboring cells")) + 
      xlab(paste("PC1 (", round(pca_percentage[1], 2), "%)", sep = "")) +
      ylab(paste("PC2 (", round(pca_percentage[2], 2), "%)", sep = "")) +
      theme_bw()
    
    print(p)
  }
  
  # Rest of your clustering and density calculations remain the same
  clust = cluster_nor(10000, stats = stats_scale_2, dat_RACIPE = dat_0_1, p = 0.05)
  cutoffs = cluster_cutoffs(10000, stats = stats_scale_2, dat_RACIPE = dat_0_1, p = 0.05)
  percentage_NetDesnoadd[, i] = calculate_density_ratios(dat_0_1 = dat_0_1, k = 15, clust = clust)
  results_NetDesnoadd[, i] <- c(length(which(clust == 0)) / 10000, length(which(clust == 1)) / 10000,
                                length(which(clust == 2)) / 10000, length(which(clust == 3)) / 10000,
                                length(which(clust == 4)) / 10000, length(which(clust == 5)) / 10000,
                                length(which(clust == 6)) / 10000)
  percentage_NetDesnoadd_3D[, i] = calculate_density_ratios(dat_0_1 = t(pca_df), k = 15, clust = clust)

  ummap_results = non_map_scale_distance(clust = clust, stats = stats_scale_2, dat = dat_0_1, cutoffs = cutoffs)
  ummap_distance = ummap_results[[1]]
  umap_vector_NetDesnoadd[, i] = ummap_results[[2]]
  
  set.seed(1)
  data_random = random_points(dat_0_1, 10000)
  clust2 = cluster_nor(10000, stats = stats_scale_2, dat_RACIPE = data_random, p = 0.05)
  unmap_random_results = non_map_scale_distance(clust = clust2, stats = stats_scale_2, dat = data_random, cutoffs = cutoffs)
  unmap_random_dis = unmap_random_results[[1]]
  dis_scale_NetDesnoadd[i] = (ummap_distance - 1) / (unmap_random_dis - 1)
  umap_vector_random_NetDesnoadd[, i] = unmap_random_results[[2]]
    if (i == 13) {
  plot(pca_df[, 1], pca_df[, 2], col = colours_pick[clust + 1], xlab = "PC1", ylab = "PC2")}
}

entropy_network=results_NetDesnoadd[2:nrow(results_NetDesnoadd),]
NetDesnoadd_entropy=infor_matrix(entropy_network)
```

The best GRN can be typically selected with the highest percentage_NetDesnoadd_3D score.

```{r}

mappingpercentage=1-percentage_NetDesnoadd_3D[1,]
GRN_choose <- which.max(mappingpercentage)
print(GRN_choose)

```
